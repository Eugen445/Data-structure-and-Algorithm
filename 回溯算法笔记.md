## 回溯算法笔记

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

```
//未剪枝的回溯
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    void flashBacking(int n, int k, int startIndex) 
    {
        if (path.size() == k) {
            res.push_back(path);
            return;
        }
        for (int i = startIndex; i <= n; ++i) {
            path.push_back(i);
            //flashBacking(n, k, startIndex + 1); //错误
            flashBacking(n, k, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combine(int n, int k) {
        res.clear();
        path.clear();
        flashBacking(n, k, 1);
        return res;
    }
};
//剪枝操作
class Solution {
public:
    //进行剪枝操作
    void flashBacking (int n, int k, int startIndex, vector<vector<int>> &res, vector<int> &path) 
    {
        if (path.size() == k) {
            res.push_back(path);
            return;
        }
        //for (int i = startIndex; k - 1 - path.size() <= n - i; ++i) {
        //为什么同样的等式上面的在vs2017上是死循环的,结果是[1,2],[1,3][1,4],[1,5][1,???] 死循环
        //甚至超出了界限
        //在n = 4, k = 2 左边的值会卡在0,右边的值会朝着负无穷前进
        //for (int i = startIndex; k - 1 - (int)path.size() <= n - i; ++i) { //这样就可以解决问题
        //这样解决问题是因为我使两边都是int
        for (int i = startIndex; i <= n - k + path.size() + 1; ++i) { //这样写的区别是什么？
        //原因呢,就是在 n - i 的计算中是会出现负数的,也就是说再符号的比较中出现了负数,负数在无符号的判定中第一位的符号被当成了数字位
        //总结下来就是在无符号的比较中,要把可能计算为负的情况分离开
        //也就是for (int i = startIndex; i <= n - k + path.size() + 1; ++i) //这个保证了等号两端不会出现负数
            path.push_back(i);
            flashBacking(n, k, i + 1, res, path);
            path.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> res;
        vector<int> path;
        flashBacking(n, k, 1, res, path);
        return res;
    }
};
```

#### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

```
//未剪枝
class Solution {
private:
    void flashBacking (int k, int n, int startIndex, int sum , vector<vector<int>>& res, vector<int>& path) 
    {
        if (sum > n) {
            return;
        }
        if (path.size() == k) {
            if (sum == n) {
                res.push_back(path);
            }
            return;
        }
        for (int i = startIndex; i <= 9; ++i) {
            path.push_back(i);
            sum += i;
            flashBacking(k, n, i + 1, sum, res, path);
            sum -= i;
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> res;
        vector<int> path;
        flashBacking(k, n, 1, 0, res, path);
        return res;
    }
};
//剪枝
class Solution {
private:
    void flashBacking(int k, int n, int startIndex, int sum, vector<vector<int>>& res, vector<int>& path) {
        if (path.size() == k) {
            if (sum == n) {
                res.push_back(path);
            }
            return;
        }
        for (int i = startIndex; i <= 9 && sum + i <= n; ++i) {
            path.push_back(i);
            sum += i;
            flashBacking(k, n, i + 1, sum, res, path);
            sum -= i;
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> res;
        vector<int> path;
        flashBacking(k, n, 1, 0, res, path);
        return res;
    }
};
```

#### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        vector<string> res;
        string s;
        if (digits.size() == 0) return res;
        flashBacking(digits, 0, res, s);
        return res;
    }
private:
    void flashBacking (const string& digits, int index, vector<string>& res, string& s ) 
    {
        if (index == digits.size()) {
            res.push_back(s);
            return;
        }
        int digit = digits[index] - '0';
        string leeters = leeterMap[digit];
        for (int i = 0; i < leeters.size(); ++i) {
            s += leeters[i];
            flashBacking(digits, index + 1, res, s);
            //s -= leeters[i];
            s.pop_back();
        }
    }
    const string leeterMap[10] { 
    //暂时认为如果string里面定义的元素长度不一的话,需要写出容量[10]
        "",     //0
        "",     //1
        "abc",  //2
        "def",  //3
        "ghi",  //4
        "jkl",  //5
        "mno",  //6
        "pqrs", //7
        "tuv", //8
        "wxyz" //9
    };
};
```

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

```
//非剪枝
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int> path;
        flashBacking(candidates, target, 0, 0, path, res);
        return res;
    }
private:
    void flashBacking (vector<int>& candidates, int target, int sum, int index, vector<int>& path, vector<vector<int>>& res) 
    {
        if (sum > target) {
            return ;
        }
        if (sum == target) {
            res.push_back(path);
        }
        for (int i = index; i < candidates.size(); ++i) { //i = index //写成了i = 0
            path.push_back(candidates[i]);
            sum += candidates[i];
            flashBacking(candidates, target, sum, i, path, res); //因为不能重复,所以从当前下标开始,不能使用之前的元素
            sum -= candidates[i];
            path.pop_back();
        }
    }
};
//排序然后剪枝
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int> path;
        sort(candidates.begin(), candidates.end());
        flashBacking(candidates, target, 0, 0, res, path);
        return res;
    }
private:
    void flashBacking (vector<int>& candidates, int target, int sum, int index, vector<vector<int>>& res, vector<int>& path) 
    {
        if (sum == target) {
            res.push_back(path);
            return ;
        }
        for (int i = index; i < candidates.size() && sum + candidates[i] <= target; ++i) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            flashBacking(candidates, target, sum, i, res, path);
            path.pop_back();
            sum -= candidates[i];
        }
    }
};
```

#### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

```
//错误示例
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        vector<vector<int>> res;
        vector<int> path;
        flashBacking(candidates, target, 0, 0, path, res);
        return res;
    }
private:
    void flashBacking (vector<int>& candidates, int target, int index, int sum, vector<int>& path, vector<vector<int>>& res) 
    {
        if (sum == target) {
            res.push_back(path);
            return ;
        }
        for (int i = index; i < candidates.size() && sum + candidates[i] <= target; ++i) {
            path.push_back(candidates[i]);
            sum += candidates[i];
            flashBacking(candidates, target, i + 1, sum, path, res);
            sum -= candidates[i];
            path.pop_back();
        }
    }
};
//正确已经剪枝
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {

        vector<bool> used(candidates.size(), false);
        vector<int> path;
        vector<vector<int>> res;
        sort(candidates.begin(), candidates.end());
        flashBacking(candidates, target, 0, 0, used, path, res);
        return res;
    }
private:
    void flashBacking (vector<int>& candidates, int target, int index, int sum, vector<bool>& used, vector<int>& path, vector<vector<int>>& res) {
        if (sum == target) {
            res.push_back(path);
            return ;
        }
        for (int i = index; i < candidates.size() && sum + candidates[i] <= target; ++i) {
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) continue;
            sum += candidates[i];
            used[i] = true;
            path.push_back(candidates[i]);
            flashBacking(candidates, target, i + 1, sum, used, path, res);
            path.pop_back();
            used[i] = false;
            sum -= candidates[i];
        }
    }
};
```

#### [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

```
class Solution {
public:
    vector<vector<string>> partition(string s) {
        vector<vector<string>> res;
        vector<string> path;
        flashBacking(s, 0, path, res);
        return res;
    }
private:
    void flashBacking (string& s, int startIndex, vector<string>& path, vector<vector<string>>& res) 
    {
        if (startIndex >= s.size()) {
            res.push_back(path);
            return ;
        }
        for (int i = startIndex; i < s.size(); ++i) {
            if (isPlindrome(s, startIndex, i)) {
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            }else continue;
            flashBacking(s, i + 1, path, res);
            path.pop_back();
        }
    }
    bool isPlindrome (const string& s, int start, int end) 
    {
        while (start < end) {
            if (s[start] != s[end]) {
                return false;
            }
            ++start, --end;
        }
        return true;
    }
};
```

#### [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

```
//错误示例
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        res.clear();
        flashBacking(s, 0, 0);
        return res;
    }
private:
    void flashBacking (string& s, int index, int pointNum) 
    {
        if (pointNum == 3) {
            if (isValid(s, index, s.size() - 1)) {
                res.push_back(s);
            }
            return ;
        }
        for (int i = index; i < s.size(); ++i) {
            if (isValid(s, index, i)) {
                s.insert(s.begin() + i + 1, '.');
                ++pointNum;
                flashBacking(s, i + 2, pointNum);
                --pointNum;
                s.erase(s.begin() + i + 1);
            }
        }
    }
    bool isValid (const string& s, int start, int end) 
    {
        if (start > end) {
            return false;
        }
        if (s[start] == '0' && start != end) { //只有一个0是0开头才合法
            return false;
        }
        int num = 0;
        while (start < end) {
            if (s[start] > '9' || s[start] < '0') {
                return false;
            }
            num = num * 10 + (s[start] - '0');
            if (num > 255) return false;
            ++start;
        }
        return true;
    }
    vector<string> res;
};
//
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        res.clear();
        flashBacking(s, 0, 0);
        return res;
    }
private:
    void flashBacking(string& s, int index, int pointNum) 
    {
        if (pointNum == 3) {
            if (isValid(s, index, s.size() - 1)) {
                res.push_back(s);
            }
            return ;
        }
        for (int i = index; i < s.size(); ++i) {
            if (isValid(s, index, i)) {
                s.insert(s.begin() + i + 1, '.');
                ++pointNum;
                flashBacking(s, i + 2, pointNum);
                --pointNum;
                s.erase(s.begin() + i + 1);
            } else break; //这一步也遗漏了许多次
        }
    }
    bool isValid(const string& s, int start, int end) 
    {
        if (start > end) {
            return false;
        }
        if (s[start] == '0' && start != end) {
            return false;
        }
        int num = 0;
        while (start <= end) { //这里的=也遗漏了
            if (s[start] > '9' || s[start] < '0') {
                return false;
            }
            num = num * 10 + (s[start] - '0');
            if (num > 255) return false;
            ++start; //这个地方遗漏了很多次了
        }
        return true;
    }
    vector<string> res;
};
```

